"""
보수 : 보충해주는 수
n진법 수 x가 있을 때, 이 x에 더해서 n 의 최소 제곱수 ~~~~

있도록 만드는 수를 x의 n의 보수

6에서 10의 최소 제곱수인 10으로 만들어 주는 수 => 4
4는 십진수 6의 10의 보수가 된다

왜 쓰냐?
컴퓨터에서 음수를 표현하기 위해 보수를 사용
컴퓨터는 사칙연산할 때 더하기만 사용가능 (뺄셈도 덧셈으로 계산)
 A - B = A + (-B)
 B의 보수를 구한 뒤에 더함

 이진법에서...
 음수를 표현하기 위해서 비트를 모두 반대로 바꿈
 1의 보수 => 어떤 수를 커다란 2의 거듭제곱수 -1( 모든 비트의 숫자가 1)에서 빼서 얻은 이진수

이진수 0101의 1의 보수 => 1111 - 0101 = 1010
    1111
  - 0101
   ------
    1010


1의 보수에서 0 은 0000000...
근데 이건 뒤집으면 1111111... 이것도 0
0을 두개로 표현 +0 -0
1의 보수는 0이 두개로 표현될 수 있다. ==> 불편함 발생

2의 보수 => 1의 보수를 구하고 1을 더하면 된다.
4비트
1 = 0001
-1 = 1111 - 0001 = 1110, 1110 + 1 = 1111


"""

hi = "0F97A3"

def solution(n):
    # n은 16진수 문자열
    # 길이 * 4 = 비트수
    l = len(n) * 4
    # 16진수 문자열을 숫자(10진수)로 바꾸기
    x = int(n, 16)
    print(x)
    # 결과 문자열
    result = ""
    # 뒤에서부터 7개씩 잘라서 2진수로 만든 뒤에 다시 10진수로 만들기
    # 뒤에서부터 자르는 이유는 오른쪽부터 작은 수를 나타내기 때문에
    for i in range(l-1, -1, -7):
        # 현재 위치 i에서 7개 잘라서 만든 이진수
        bin = ""
        # x의 i-j번째 비트 판별
        for j in range(7):
            # 음수만큼 이동이 일어났다 => 자리수가 넘어갔다 ==> 더이상 바꿀 자리가 없다
            if i - j < 0:
                break
            bin += "1" if x & (1 << i - j) else "0" # x의 i - j 번째 비트가 1인지 아닌지
        print(bin, end = " ")
        dec = int(bin, 2) # 2진수를 10진수로 바꿀 때
        result += str(dec) + " "
    print()
    print(result)

solution(hi)