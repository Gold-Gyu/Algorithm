# 백트래킹 : 가능한 모든 경우를 추려내서 정답을 찾는 것, 성능이 좋지 않지만 모든 경우를 돌려서 답을 찾는 과정
# 백트래킹에 익숙해지기 위해서 15문제는 풀어야함
# 완전 탐색과 다른 이유 : 백트래킹은 재귀를 통해 이루어짐

# 모든 문제가 백트래킹으로 보일 때가 있음
# 복잡도에 대한 고려가 필요하다.
# 복잡도에 대한 기준을 잡는다.
"""
[1] 종료조건(n)을 설정 : 항상 반드시 끝나야한다.
    - 기초 문제에서 종료조건을 설정하는 것은 어렵지 않음
        n : 숫자번호(index)에 어떤 수를 포함할 것인가 아닌가?
    - 어려운 문제에서는 여기서 종료조건을 잡기가 힘들다.
    ★ 모든 정답 처리는 종료지점에서 꼭 하기기
    종료조건 :
    인덱스가 리스트의 길이만큼 즉, 모든 자리를 정해줬다면 종료

[2] 직접 손으로 트리를 만들어본다. 재귀함수가 익숙해지기 전까지는 직접 그려본다.
    - 모든 경우를 펼쳐서 보여주는 과정.
    - 시각적으로 표현해서 이해도를 높임
    - n 즉, 인덱스를 활용한다.
    - 0번째 인덱스에 포함할 것인지 포함하지 않을 것인지를 결정한다.
    - ....
    - 마지막 n-1번째 인덱스에서 숫자를  포함할 것인지 포함하지 않을 것인지


    ★ 모든 과정을 꼭 그려봐라







"""
import sys
sys.stdin = open("부분 수열의 합.txt", "r")

# 이진트리를 먼저 고려한 뒤에 멀티트리를 고려한다.

def dfs(idx,s):

    global cnt

    # 가지치기
    if s > K:
        return



    # 종료조건  (항상 idx와 관련되서 정한다)
    if idx == N:

        # 정답처리는 종료조건에서 한다
        if s == K:
            cnt += 1

        return  # 일단 종료조건을 만나면 return이 되고 if s == K에 걸리면 갯수를 세주고 return

    # 재귀호출(하부호출)

    # 1. 포함하는 경우
    dfs(idx+1, s+lst[idx])
    # 2. 포함하지 않는 경우
    dfs(idx+1, s)



T = int(input())

for tc in range(1, T+1):
    N, K = map(int, input().split())
    lst = list(map(int, input().split()))
    cnt = 0
    dfs(0, 0)
    print(f"#{tc} {cnt}")

